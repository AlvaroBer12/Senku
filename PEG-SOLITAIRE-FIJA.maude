mod FICHA-SOLITAIRE-FIJA is
    protecting NAT .

    sort Ficha ListaFichas Board .
    subsort Ficha < ListaFichas < Board .

    ops x o : -> Ficha [ctor] .

    op nil : -> ListaFichas [ctor] .
    op __ : ListaFichas ListaFichas -> ListaFichas [assoc id: nil prec 1] .
    
    op nilL : -> Board [ctor] .
    op _,_ : Board Board -> Board [assoc id: nilL prec 2] .

    var F : Ficha .
    var L : ListaFichas .
    vars B T : Board .

    op countList : ListaFichas -> Nat .
    eq countList (x) = 1 .
    eq countList (o) = 0 .
    eq countList (F L) = countList(F) + countList(L) .

    op count : Board -> Nat .
    eq count (L) = countList(L) .
    eq count (L , B) = countList(L) + count(B) .

    op size : ListaFichas -> Nat .
    eq size(F) = 1 .
    eq size (F L) = s size(L) .

    vars c x1 y1 i p : Nat .

    op createRow : Nat Nat -> ListaFichas .
    eq createRow(c, p) = if p > c then nil else x createRow(c, s p) fi .

    op createBoard : Nat Nat -> Board .
    eq createBoard(c, i) = if i > c then nilL else (createRow(c, 1)) , ( createBoard(c, s i) ) fi .
   
    op initial : Nat -> Board .
    eq initial(c) = createBoard(c, 1) .

    op placeLibre : Nat Nat Nat -> ListaFichas .
    eq placeLibre(c, y1, p) = if p > c then nil else (if p == y1 then o placeLibre(c, y1, s p) else x placeLibre(c, y1, s p) fi ) fi .

    op searchLibre : Board Nat Nat Nat -> Board .
    eq searchLibre(nilL, x1, y1, i) = nilL .
    eq searchLibre((L , B), x1, y1, i) = if i == x1 then ( placeLibre(countList(L), y1, 1) , B ) else ( L , searchLibre(B, x1, y1, s i) ) fi .

    op libre : Board Nat Nat -> Board .
    eq libre (B, x1, y1) = searchLibre(B, x1, y1, 1) .  

    op four : -> Board .
    eq four = (
        (x x x x),
        (x x x x),
        (x x x o),
        (x x x x)
    ) .

    op five : -> Board .
    eq five = (
        (x x x x x),
        (x x x x x),
        (x x x o x),
        (x x x x x),
        (x x x x x)
    ) .

    vars v1 v2 v3 v1' v2' v3' : ListaFichas .
    rl [right] : x x o => o o x .
    rl [left] : o x x => x o o .
    crl [down] :
        (v1 x v1'),
        (v2 x v2'),
        (v3 o v3')
        =>
        (v1 o v1'),
        (v2 o v2'),
        (v3 x v3')
        if size(v1) == size(v2) /\ size(v2) == size(v3) .
    crl [up] :
        (v1 o v1'),
        (v2 x v2'),
        (v3 x v3')
        =>
        (v1 x v1'),
        (v2 o v2'),
        (v3 o v3')
        if size(v1) == size(v2) /\ size(v2) == size(v3) .
endm